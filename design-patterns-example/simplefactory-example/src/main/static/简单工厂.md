# 简单工厂

## 定义
  由一个工厂对象决定创建出哪一种产品类的实例
## 类型
  创建型，但不属于GOF23种设计模式
## 使用场景
 - 工厂类负责创建的对象比较少
 - 客户端（应用层）只知道传入工厂类的参数，对于如何创建对象（逻辑）不关心
## 优点
  只需要传入一个正确的参数，就可以获取所需要的对象而无须知道其创建细节
## 缺点
  简单工厂类的职责相对过重，增加新的产品需要修改工厂类的判断逻辑，违背了开闭原则。

## 简单工厂在源码中的使用

### Calendar

```java
// 这里使用的是静态方法，因为不需要再通过继承进行扩展。如需扩展就不使用static关键字
public static Calendar getInstance(TimeZone zone, Locale aLocale){
        return createCalendar(zone, aLocale);
    }

    private static Calendar createCalendar(TimeZone zone, Locale aLocale)
    {
        CalendarProvider provider = LocaleProviderAdapter.getAdapter(CalendarProvider.class, aLocale).getCalendarProvider();
        if (provider != null) {
            try {
                return provider.getInstance(zone, aLocale);
            } catch (IllegalArgumentException iae) {
                // fall back to the default instantiation
            }
        }
        Calendar cal = null;
        if (aLocale.hasExtensions()) {
            String caltype = aLocale.getUnicodeLocaleType("ca");
            if (caltype != null) {
                // 根据不同的类型创建日期对象
                switch (caltype) {
                case "buddhist":
                cal = new BuddhistCalendar(zone, aLocale);
                    break;
                case "japanese":
                    cal = new JapaneseImperialCalendar(zone, aLocale);
                    break;
                case "gregory":
                    cal = new GregorianCalendar(zone, aLocale);
                    break;
                }
            }
        }
        if (cal == null) {
            if (aLocale.getLanguage() == "th" && aLocale.getCountry() == "TH") {
                cal = new BuddhistCalendar(zone, aLocale);
            } else if (aLocale.getVariant() == "JP" && aLocale.getLanguage() == "ja"
                       && aLocale.getCountry() == "JP") {
                cal = new JapaneseImperialCalendar(zone, aLocale);
            } else {
                cal = new GregorianCalendar(zone, aLocale);
            }
        }
        return cal;
    }
```



