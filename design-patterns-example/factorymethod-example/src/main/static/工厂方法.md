# 工厂方法

## 定义
  定义一个创建对象的接口（抽象方法），让实现这个接口的类（实现抽象方法）来决定实例化哪个类，工厂方法让类的实例化推迟到子类中进行，即通过子类实现抽象方法来创建对象。
  工厂方法就是用来解决同一产品等级的业务抽象问题。
## 类型
  创建型
## 使用场景
 - 创建对象需要大量的重复代码
 - 客户端（应用层）不依赖于产品类实例如何被创建、实现等细节
 - 一个类通过其子类来指定创建哪个对象
## 优点
  用户只需要关心所需产品对应的工厂，无须关心创建细节。加入新的产品符合开闭原则，提高了可扩展性。
## 缺点
  实现类的个数容易过多（增加新产品的时候，不仅需要编写新的产品类还需要编写对应的工厂类，因此类的个数增加）、增加复杂度。
  工厂方法本身使用了抽象，我们需要引入抽象层，如果想要动态创建可能还会使用反射技术，这都增加了系统的抽象性和理解难度
## 工厂方法在源码中的使用

Collection接口相当于抽象工厂（因为它处理的是等级组问题即多个类型的产品），其中它里面的*Iterator<E> iterator()*方法相当于工厂方法。ArrayList实现了这个方法，该方法为ArrayList生产
*Itr*，Itr是Iterator类型。还有ILoggerFactory和Logger产品族对应的工厂方法的使用。

```java
  public Iterator<E> iterator() {
        return new Itr();
    }
    /**
     * An optimized version of AbstractList.Itr
     */
    private class Itr implements Iterator<E> {
        int cursor;       // index of next element to return
        int lastRet = -1; // index of last element returned; -1 if no such
        int expectedModCount = modCount;

        public boolean hasNext() {
            return cursor != size;
        }

        @SuppressWarnings("unchecked")
        public E next() {
            checkForComodification();
            int i = cursor;
            if (i >= size)
                throw new NoSuchElementException();
            Object[] elementData = ArrayList.this.elementData;
            if (i >= elementData.length)
                throw new ConcurrentModificationException();
            cursor = i + 1;
            return (E) elementData[lastRet = i];
        }

        public void remove() {
            if (lastRet < 0)
                throw new IllegalStateException();
            checkForComodification();

            try {
                ArrayList.this.remove(lastRet);
                cursor = lastRet;
                lastRet = -1;
                expectedModCount = modCount;
            } catch (IndexOutOfBoundsException ex) {
                throw new ConcurrentModificationException();
            }
        }

        @Override
        @SuppressWarnings("unchecked")
        public void forEachRemaining(Consumer<? super E> consumer) {
            Objects.requireNonNull(consumer);
            final int size = ArrayList.this.size;
            int i = cursor;
            if (i >= size) {
                return;
            }
            final Object[] elementData = ArrayList.this.elementData;
            if (i >= elementData.length) {
                throw new ConcurrentModificationException();
            }
            while (i != size && modCount == expectedModCount) {
                consumer.accept((E) elementData[i++]);
            }
            // update once at end of iteration to reduce heap write traffic
            cursor = i;
            lastRet = i - 1;
            checkForComodification();
        }

        final void checkForComodification() {
            if (modCount != expectedModCount)
                throw new ConcurrentModificationException();
        }
    }
```



