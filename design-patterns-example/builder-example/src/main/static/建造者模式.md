# 建造者模式

## 定义
 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。用户只需指定需要建造的类型就可以得到它们，建造过程及细节不需要知道。
## 类型
  创建型
## 适用场景
 - 如果一个对象有非常复杂的内部结构（很多属性）
 - 想把复杂对象的创建和使用分离
## 优点
 - 封装性好，创建和使用分离
 - 扩展性好、建造类之间独立、一定程度上解耦

## 缺点
 - 产生多余的Builder对象
 - 产品内部发生变化，建造者都需要修改，成本较大

## 建造者模式和工厂模式比较

 - 建造者模式更注重方法的调用顺序，而工厂模式更注重生产产品
 - 创建对象的粒度不同，建造者模式可以创建复杂的产品，有各种复杂的部件组成。而工程模式创建出来的都几乎一个样子
 - 工厂模式注重把产品创建出来，而建造者不仅要创建出产品，还要知道产品有哪些部件组成的
 
## 简单需求说明
 有一个课程需要上线在网站，这个课程需要满足以下条件：课程名、课程的课件资源以及视频资源，只有这个三个组件有了
 才能组装成上线的课程。这里在创建课时，需要有顺序的执行，最终得到一个符合要求的课程。 
 
## 建造者模式在源码中的使用

### jdk的StringBuilder和StringBuffer

```java
// 如StringBuilder的append方法
    @Override
     public StringBuilder append(String str) {
         super.append(str);
         return this;
     }
// 如StringBuffer的append方法
 @Override
    public synchronized StringBuffer append(String str) {
        toStringCache = null;
        super.append(str);
        return this;
    }     
```

### MyBatis的SqlSessionFactoryBuilder

```java
 public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) {
    try {
      // XML配置的builder 来创建 Configuration 
      XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);
      // parse方法创建Configuration ，SqlSessionFactoryBuilder的build方法创建SqlSessionFactory
      return build(parser.parse());
    } catch (Exception e) {
      throw ExceptionFactory.wrapException("Error building SqlSession.", e);
    } finally {
      ErrorContext.instance().reset();
      try {
        inputStream.close();
      } catch (IOException e) {
        // Intentionally ignore. Prefer previous error.
      }
    }
  }
  // 
  public SqlSessionFactory build(Configuration config) {
    return new DefaultSqlSessionFactory(config);
  }
```
