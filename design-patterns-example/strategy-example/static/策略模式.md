## 策略模式

### 定义

定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化不会影响到使用算法的用户。即把不同的算法封装到不同的类里面，让它们之间可以相互替换， 应用层不会受到影响。

### 类型

行为型

### 使用场景

```text
1 系统有很多类，而他们的区别仅仅在于它们的行为不同
  - 使用策略模式就可以动态地让一个对象在多个行为中选择一种行为，也就是说我们把这个对象不同的行为放到不同的类里面，而每一种行为对应着一种策略
2 一个系统需要动态地在几种算法中选择一种
  - 这里算法就是策略，策略里面封装的就是一系列逻辑以及计算方式
```

### 优点

```text
1 符合开闭原则
  - 策略模式提供了对开闭原则的完美支持，我们可以在不修改原有系统的基础上选择具体的行为
2 避免使用多重条件转移语句
  - 大量的if...else, switch。 我们把具体的策略行为分离为一个一个的单独的类来替换if...else里面的逻辑，这样写也可以降低代码的耦合
3 提高算法的保密性和安全性  
  - 在使用的时候我们只知道策略的功能，不需要知道具体的细节。在具体的策略类中封装了不同的行为和算法以及相关的数据结构，对于应用层来说，是不需要知道内部的细节的。比如使用Dubbo的服务提供者，不需要知道内部逻辑的细节。
```

### 缺点

```text
1 应用层必须知道所有的策略类，并自行决定使用哪一个策略类
2 产生很多策略类
```

### 策略模式相关的设计模式

**策略模式和工厂模式**

```text
1 工厂模式是创建型的设计模式，策略模式是行为型的设计模式
2 工厂模式接受指令，创建符合要求的对象。策略模式接受创建好的对象，从而实现不同的行为
```

**策略模式和状态模式**

```text
1 使用策略模式的时候，应用层需要知道应该选择哪一种策略。在使用状态模式的时候，应用层是不需要关心具体的状态，这些状态会自动转换
2 如果系统中某个类的对象存在多种状态，不同状态下行为又有差异，而且这些状态可以发生转换时可以使用状态模式。如果系统中某个类的某种行为存在多种实现方式，如促销是个行为，这种行为就有多种实现方式，这种情况下应该使用策略模式。
```

### 简单需求



### 策略模式演练





